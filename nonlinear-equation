import matplotlib.pyplot as plt
import math
import pandas as pd

# Чтобы числа не выводились в научной нотации
pd.options.display.float_format = '{:.8f}'.format

# Константы функции
a0, a1, a2, a3 = -1.15, -1.14, 0.44, 7.98

# Функция
def f(x):
    return a0 + a1 * x + a2 * x**2 + a3 * math.sin(x)

# Вычисление значений функции
def compute_values(func, start, end, step):
    x_values, y_values = [], []
    current = start
    while current <= end:
        x_values.append(current)
        y_values.append(func(current))
        current += step
    return x_values, y_values

# Локализация корней
def find_roots(x_values, y_values):
    intervals = []
    for i in range(len(x_values) - 1):
        if y_values[i] * y_values[i + 1] < 0:
            intervals.append((x_values[i], x_values[i + 1]))
    x_zeros = [(a + b) / 2 for a, b in intervals]
    y_zeros = [f(x0) for x0 in x_zeros]
    return intervals, x_zeros, y_zeros

# Метод половинного деления
def bisection_method(func, a, b, eps=1e-5, max_iter=1000):
    fa = func(a)
    fb = func(b)
    for i in range(1, max_iter + 1):
        c = (a + b) / 2
        fc = func(c)
        if abs(fc) < eps or (b - a) / 2 < eps:
            return c, i
        if fa * fc < 0:
            b, fb = c, fc
        else:
            a, fa = c, fc
    return c, i

# Метод пропорциональных частей 
def proportional_parts_method(func, a, b, eps=1e-5, max_iter=1000):
    fa = func(a)
    fb = func(b)
    for i in range(1, max_iter + 1):
        x = (a * fb - b * fa) / (fb - fa)
        fx = func(x)
        if abs(fx) < eps or abs(b - a) < eps:
            return x, i
        if fa * fx < 0:
            b, fb = x, fx
        else:
            a, fa = x, fx
    return x, i

# Таблица локализации
def print_localization_table(intervals, x_zeros, y_zeros):
    df = pd.DataFrame({
        'aᵢ': [a for a, _ in intervals],
        'bᵢ': [b for _, b in intervals],
        'x прибл.': x_zeros,
        'f(x прибл.)': y_zeros
    })
    print("Локализация корней функции:")
    print(df.to_string(index=True))

# Таблица найденных корней
def print_roots_table(title, intervals, roots, func):
    df = pd.DataFrame({
        'aᵢ': [a for a, _ in intervals],
        'bᵢ': [b for _, b in intervals],
        'xᵢ': roots,
        'f(xᵢ)': [func(x) for x in roots]
    })
    print(f"\n{title}")
    print(df.to_string(index=True))

# График для локализации корней
def plot_localization(x, y, intervals):
    plt.plot(x, y, color="blue", label="f(x)")
    plt.axhline(0, color="black", linewidth=1)

    # Покажем локализацию красными вертикальными отрезками
    for a, b in intervals:
        plt.axvline(a, color="red", linestyle="--", linewidth=1)
        plt.axvline(b, color="red", linestyle="--", linewidth=1)

    plt.title("Локализация корней функции")
    plt.xlabel("x")
    plt.ylabel("f(x)")
    plt.grid(True)
    plt.legend()
    plt.show()

# Таблица количества итераций и графики
def analyze_iterations(func, intervals, eps_list):
    iterations_table = {
        "ε": eps_list,
        "log(ε)": [math.log10(eps) for eps in eps_list]
    }

    for idx, (a, b) in enumerate(intervals):
        bis_iters = []
        prop_iters = []
        for eps in eps_list:
            _, bi = bisection_method(func, a, b, eps)
            _, pi = proportional_parts_method(func, a, b, eps)
            bis_iters.append(bi)
            prop_iters.append(pi)
        iterations_table[f"Метод половинного деления (x{idx+1})"] = bis_iters
        iterations_table[f"Метод пропорциональных частей (x{idx+1})"] = prop_iters

    df_iters = pd.DataFrame(iterations_table)
    print("\nТаблица количества итераций:")
    print(df_iters.to_string(index=False))

    for idx in range(len(intervals)):
        plt.figure(figsize=(6,4))
        plt.plot(df_iters["log(ε)"], df_iters[f"Метод половинного деления (x{idx+1})"], '--', label='Метод половинного деления')
        plt.plot(df_iters["log(ε)"], df_iters[f"Метод пропорциональных частей (x{idx+1})"], '-', label='Метод пропорциональных частей')
        plt.title(f"График зависимости количества итераций от точности для x{idx+1}")
        plt.xlabel("log(ε)")
        plt.ylabel("Количество итераций")
        plt.grid(True)
        plt.legend()
        plt.show()

# Основной блок 
start, end, step = 0, 12, 0.5  
x, y = compute_values(f, start, end, step)
intervals, x_zeros, y_zeros = find_roots(x, y)

print_localization_table(intervals, x_zeros, y_zeros)
plot_localization(x, y, intervals)

eps_list = [0.1, 0.01, 0.001, 0.0001, 0.00001]

for eps in eps_list:
    print(f"\n{'-'*50}\nРезультаты для eps = {eps}\n")
    roots_bis = [bisection_method(f, a, b, eps)[0] for a, b in intervals]
    roots_prop = [proportional_parts_method(f, a, b, eps)[0] for a, b in intervals]
    print_roots_table(f"Корни функции (метод половинного деления) при eps={eps}", intervals, roots_bis, f)
    print_roots_table(f"Корни функции (метод пропорциональных частей) при eps={eps}", intervals, roots_prop, f)

# Вызов функции анализа итераций и построения графиков
analyze_iterations(f, intervals, eps_list)
